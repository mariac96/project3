# -*- coding: utf-8 -*-
"""forecast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ydu0MGNOOpWTs4JI5Fnzx4qBaZyc03av

ΚΑΡΛΗΣ ΝΙΚΟΛΑΟΣ 1115201800068


ΧΑΤΖΗΠΑΥΛΟΥ ΜΑΡΙΑ 1115201400223
"""

from google.colab import drive
drive.mount('/content/gdrive')

import math
import matplotlib.pyplot as plt
import keras
import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
from keras.layers import *
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from sklearn.model_selection import train_test_split
from keras.callbacks import EarlyStopping

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x
import tensorflow as tf
device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
  raise SystemError('GPU device not found')
print('Found GPU at: {}'.format(device_name))

"""Διάβασμα του αρχείου με μετατροπή σε dataframe"""

# read files
df = pd.read_csv('/content/gdrive/MyDrive/nasdaq2007_17.csv', header=None,sep = '\t')

df = df.reset_index(drop=True)

print("Number of rows and columns:", df.shape)

n = 5

print(df)

print(df.shape)

"""το df.shape[0] είναι το πλήθος των γραμμών και το df.shape[1] είναι το πλήθος των στηλών. 

Αφού πρέπει να χωρίσουμε κάθε time series σε 80% training set και 20% test set βρίσκουμε σε ποιο column του dataframe αντιστοιχεί το 80% του time series που είναι το df.shape[1] * 0.8

Αποθηκεύουμε το αποτέλεσμα στην μεταβλητή percentage
"""

rows = df.shape[0]
columns = df.shape[1] - 1

percentage = int(columns * 0.80)

"""Σκεφτήκαμε να εφαρμόσουμε τον κώδικα που μας δόθηκε αλλά αντί για ένα dataframe με μία στήλη με πολλές γραμμές έχουμε πολλές στήλες με πολλές γραμμές.


Ξεκινήσαμε να κάνουμε iterate κάθε γραμμή του dataframe με το iterrows(). Παρατηρήσαμε ότι με την χρήση του row εμφανίζονταν κάθετα τα δεδομένα της γραμμής, σαν στήλη, επομένως σε κάθε επανάληψη δημιουργούμε ένα temp dataframe που έχει τα time series κάθε γραμμής. Έτσι το dataframe temp είναι σαν αυτό που έχει στο παράδειγμα και μπορούμε δημιουργήσουμε σε κάθε επανάληψη τα αντίστοιχα X_train, y_train και y_test, και τα αποθηκεύουμε σε αντίστοιχες λίστες trainXList, trainYList και testList.

Το scale γίνεται ξεχωριστά σε κάθε γραμμή του dataframe
"""

trainXList = []
trainYList = []

testList = []

sc = MinMaxScaler(feature_range = (0, 1))

for index, row in df.iterrows():
  temp = pd.DataFrame(row[1:].astype(float))
  temp.columns = ['price']
  training_set = temp.iloc[:percentage].values
  test_set = temp.iloc[percentage:].values
  training_set_scaled = sc.fit_transform(training_set)
  trainingSize = training_set.shape[0]
  
  X_train = []
  y_train = []
  for i in range(60, (trainingSize)):
      X_train.append(training_set_scaled[i-60:i, 0])
      y_train.append(training_set_scaled[i, 0])
  X_train, y_train = np.array(X_train), np.array(y_train)

  X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
  trainXList.append(X_train)
  trainYList.append(X_train)

  dataset_train = temp.iloc[:percentage]
  dataset_test = temp.iloc[percentage:]

  testSize = dataset_test.shape[0]
  
  dataset_total = pd.concat((dataset_train, dataset_test), axis = 0)

  inputs = dataset_total[len(dataset_total) - len(dataset_test) - 60:].values

  inputs = inputs.reshape(-1,1)
  inputs = sc.transform(inputs)
  X_test = []
  for i in range(60, testSize+60):
      X_test.append(inputs[i-60:i, 0])

  X_test = np.array(X_test)
  X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

  testList.append(X_test)

print(X_train.shape)

"""Το μοντέλο που μας δόθηκε"""

from keras.models import Sequential

model = Sequential()  # Adding the first LSTM layer and some Dropout regularisation
model.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2)) # Adding a second LSTM layer and some Dropout regularisation
model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.2)) # Adding a third LSTM layer and some Dropout regularisation
model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.2)) # Adding a fourth LSTM layer and some Dropout regularisation
model.add(LSTM(units = 50))
model.add(Dropout(0.2)) # Adding the output layer
model.add(Dense(units = 1))

# Compiling the RNN
model.compile(optimizer = 'adam', loss = 'mean_squared_error')

"""Κάνουμε επαναληπτικά fit το model για κάθε Χ_train, y_train που δημιουργήσαμε πριν και έχουμε αποθηκευμένα στις λίστες τις οποίες κάνουμε iterate. 

Το batch_size είναι 1024 που είναι το μεγαλύτερο δυνατό.

Επιλέχθηκε μεγάλο batch_size επειδή κάνουμε πολλές φορές fit το μοντέλο και είναι πιο γρήγορο στην εκπαίδευση με μεγάλο batch_size αλλά επειδή εκπαιδεύεται πολλές φορές δεν θα έχει μεγάλο πρόβλημα στην ακρίβεια του μοντέλου.

Ο αριθμός των epochs είναι 5. Δεν χρειαζόμαστε πολλά epochs διότι εφαρμόζουμε το μοντέλο, 360 φορές για αυτό επιλέξαμε μικρό αριθμό, αφού θα έχουμε 1500 epochs συνολικά

"""

for X_train, y_train in zip(trainXList, trainYList):
  # Fitting the RNN to the Training set
  model.fit(X_train, y_train, epochs = 5, batch_size = 1024)

print(len(testList))

# Calling save('model1') creates a SavedModel folder model1
model.save('/content/gdrive/MyDrive/model1')

"""Κάνουμε visualize τα Real Stock Price και τα Predicted Stock Price για ορισμένες μετοχές"""

for index, X_test in enumerate(testList):
  if(index < n):

    predicted_stock_price = model.predict(X_test)
    predicted_stock_price = sc.inverse_transform(predicted_stock_price)


    df2 = pd.DataFrame(predicted_stock_price)

    frames = [df.loc[index][1:percentage+1], df2]
  
    result = pd.concat(frames)
    
    # Visualising the results
    plt.plot(df.loc[index][1:], color = 'red', label = 'Real Stock Price')
    plt.plot(result.values, color = 'blue', label = 'Predicted Stock Price') #, predicted_stock_price,
    # plt.xticks(np.arange(0,459,50))
    plt.title('Stock Price Prediction')
    plt.xlabel('Time')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()